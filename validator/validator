#!/usr/bin/env ruby

require "thor"
require "uri"

require_relative "validator_lib"

class ValidatorCLI < Thor
  include ValidatorLib

  def self.exit_on_failure?
	  true
	end

  class_option :host,
    :desc => %Q(
      When following links, replaces the link's host with the given host.

      When this option is set, will also replace all 'https' schemes with 'http'.

      This option is useful for local development. E.g. when serving from a local server on port 3000,
      pass --host="localhost:3000" to make the validator follow links on the local machine.
    ), :default => nil, :type => :string

  desc "all MANIFEST_FILE_OR_URL", "Validates scheduling links MANIFEST_FILE_OR_URL."
  long_desc <<-DESC
    Validates the specified manifest file and all named resources.

    You may pass in a path or a URL to validate.
  DESC
  def all(file_or_url)
    puts "Validating #{file_or_url}"
    state = State.new
    errors = validate_manifest_helper(state, file_or_url)
    print_errors(errors)
  end

  desc "manifest MANIFEST_FILE_OR_URL", "Validates manifest MANIFEST_FILE_OR_URL."
  long_desc <<-DESC
    Validates the specified manifest file.

    You may pass in a path or a URL to validate.

    Note that this option validates only the manifest file - resources named by the manifest
    file are not validated. To validate all named resources, use the 'all' command.
  DESC
  def manifest(file_or_url)
    puts "Validating #{file_or_url}"

    state = State.new
    print_errors(validate_manifest_helper(state, file_or_url))
  end

  desc "location LOCATION_FILE_OR_URL", "Validates location LOCATION_FILE_OR_URL."
  def location(file_or_url)
    puts "Validating #{file_or_url}"
  end

  desc "schedule SCHEDULE_FILE_OR_URL", "Validates schedule SCHEDULE_FILE_OR_URL."
  def schedule(file_or_url)
    puts "Validating #{file_or_url}"
  end

  desc "slot SLOT_FILE_OR_URL", "Validates location SLOT_FILE_OR_URL."
  def slot(file_or_url)
    puts "Validating #{file_or_url}"
  end

 private

 # Validates the given manifest file or URL. Returns an array of errors.
  def validate_manifest_helper(state, f)
    errors = []
    errors.concat(validate_manifest_url_path(f))

    contents = read_resource(f, errors)
    errors.concat(contents.nil? ? [] : validate_manifest(state, f, contents))
    errors.concat(state.errors())
  end

  # If errors is not empty - prints the contents of errors and raises a Thor::Error.
  def print_errors(errors)
    unless errors.empty?
      say "Validation failed", Shell::Color::RED
      raise Thor::Error, "#{errors.join("\n")}"
    else
      say "Validation succeeded!", Shell::Color::GREEN
    end
  end

  # Attempts to get the contents of loc, which may be a URL or file path.
  # If the read fails, returns nil and adds an error message to errors.
  # Returns a string containing the contents of the URL or file.
  def read_resource(loc, errors)
    if is_url(loc)
      url = URI.parse(loc)
      req.add_field("User-Agent", "github.com/lazau/scheduling-links-aggregator/validator")
      resp_body = ""
      Net::HTTP.start(url.host, url.port) do |h|
        req = Net::HTTP::Get.new(url)
        resp = h.request(req)

        if resp.code != "200"
          errors << "Unable to read #{loc} (HTTP status code #{resp.code})."
          raise Thor::Error, "Unable to fetch #{loc}: HTTP response code #{resp.code}"
        end
        resp_body = resp.body
      end
      resp_body
    end

    if !File.exist?(loc)
      errors << "File #{loc} does not exist."
      return nil
    else 
      return File.read(loc)
    end
  end
end

ValidatorCLI.start(ARGV)
